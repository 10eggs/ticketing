$npm init -y // all default on YES
$npm install typescript ts-node-dev express @types/express

$tsc --init


#This time we are running Kubernetess stuff directly, straight after creation of new service
warning: LF will be replaced by CRLF in ticketing/auth/package-lock.json.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in ticketing/auth/package.json.
The file will have its original line endings in your workingss





#If you did not see your server restart after changing the index.ts file, do the following:
#Open the package.json file in the ‘auth’ directory
#Find the ‘start’ script
#Update the start script to the following:
$ts-node-dev --poll src/index.ts

#To run skaffold
$skaffold dev

#To prevent problem with cert in chrome
$thisisunsafe

#Remove dir from git
$git rm -r --cached myFolder

#To interact between TS and Mongoose we need to write some custom code as mongoose doesn't support TS natively

#Mongoose User Model - Represents the entire colletion of users
#Mongoose User Document - Represents one single user
#Initially there is no check against constructor properties, which means you can do typo in property name for example and TS will not complain

#Creating User Model
#1. Create scheme - tell mongoose specifically about all the different properties that model will going to have
#2. Create a model in MongoDB
#3. ISSUE no1: When I'll try to create User object with passing any arguments, there is no check provided by TS, so I can do a mistake by passing wrong arguments
#4. Solution - create an interface which describe constructor properties. Next, use new build() function to use interface
#5. build() function need to be connected to User model. We can achieve it by add 'static' property to the model
#6. Initially, we'll end up with error - TS doesn't understand what does it mean to assign a property to a static object
#7. Hence we need to boost our Model to be aware of this function
#8. Solution - introduce another interface to describe what properties our User model should have
#9. In UserModel interface we are introducing GENERICS
#10. After that our mongoose.model will have two generic arguments - any and UserModel
#11. ISSUE no2: Let's say I'd like to print my UserDocument in console - it shows me all properties, even these ones which are added by mongoose automatically.
#12. Solution: Introduce interface for User Document
#13. 

#Hashing Password
#1. Signup process
#2. Create salt
#3. Buffer - raw array of byte inside of it

#Middleware in Mongoose
#1. using .pre()
#2. using function rather than arrow function. Whenever we are calling middleware function we've got an access
# to Entity which we are going to persist to database by calling 'this' keyword - if we would use arrow function instead then 'this' refeering to context of entire file


#AUTHENTICATION STRATEGIES!
# To handle cookies we'll be using cookie-session package:
# npm install cookie-session @types/cookie-session
# to create JWT we need jsonwebtoken

#Useful links:
#https://www.base64decode.org/
#jwt.io

#Securely Storing Secrets with Kubernetes
#In order to do that - use Secret object in kubernetes
#Imperative approach (by using command):
$kubectl create secrete generic jwt-secret --from-literal=<KEY>=<VALUE>
#kubectl create secret generic jwt-secret --from-literal=JWT_KEY=9283hdin92unc9e0j2neAASUDH


#To get Secrets
$kubectl get secrets

#Mongo db returns '_id', which is usually called 'id'
 #This lines won't work in TS as TS can't detect if this env variable was created or not
  const userJwt = jwt.sign({
    id: user.id,
    email: user.email
  },process.env.JWT_KEY);

  #To mitigate this problem we are going to implement handler which detect during the boot process if env variable is there or not
  #EXCLAMATION MARK in typescript indicate that we have handled suggested error, and typescript shouldn't worry about it


#We can override the way how the javascript object is represented by JSON.stringify. To do so, we need to implement toJSON() method for our object, i.e.:
$const person = {name='Tomek',toJSON(){return 1;}}
#It always return 1

#SHORTCUT
#Ctrl+Shift+` to create new terminal.

#SHORTCUT
#ctrl+shift+p - open PANE
#ctrl+e - search files by name

#Middleware always run in order

#CurrentUser - to prevent access to cookies from the browser
#After creation of CurrentUser handler we want to introduce another middleware to set access to routes can be used by current user.
#


#INTRODUCING TESTS TO OUR PROJECT
#supertest doesn't manage cookie for us by default
#Why we are using SSR rather than CSR?

#1. Just to show how to handle it in microservices world,
#2. Better for mobile devices
#3. Better for SEO 


#Suggestion Regarding a Default Export Warning
#Information:
#Anonymous arrow functions cause Fast Refresh to not preserve local component state.

#Please add a name to your function, for example:
#Before
#export default () => <div />;
#After
#const Named = () => <div />;
#export default Named;


#Starting with Next.JS
#In each file inside pages directory we'll be exporting React components
#Next.js working differently than React router
#Whenever next.js started it is reading all the files from pages folder
#Next can distinct files by names and treat this filenames as a routes

#Making changes in ingress
#We've got two services set on port 3000
#If we've got many paths, ingress will try to match them in order
#So the best approach here is to use the most specific paths at the very beginning, and
#And leave generic ones at the end (for example /?(.*) means anything)

Problem with Kubernetess/Ingress
#Troubleshooting: 
#https://kubernetes.github.io/ingress-nginx/troubleshooting/
#kubectl get ing
#kubectl describe ing

#Next.js running in container cannot react on changes in file immmidiately - we need to do some changes there.


##CSS handling
#Bootstrap - global for whole proj
#First - create _app.js - critial to call it exactly the same


#Check how to handle braces for functions etc
#Short circut evaluation - &&. So we can use it as a check, x && f() , if x false we won't execute second part

#Server Side Rendering Overview
#How to make a request to currentUser while our application is build
#How SSR works:

#1. Inspect incoming request - determine set of components to show
#2. Call those components 'getInitialProps' static method
#3. Render each component with data from 'getInitialPros' one time
#4. Assamble HTML from all components, send back response


#Fetching data during SSR
#Differences between requesting data from server vs from the client
#We are receiving and error while we are trying to send a request from getInitialProps method in Next.js
#The reason why we get it is a Kubernetess


####  SUPER CRITICAL ###
#OPTION NO.1
# We are running next.js inside our CONTAINER
# So call done by the server from getInitialProps is done by node INSIDE our container,
so if we are not specify domain (we don't need to specify domain from client, as we know ticketing.dev = 127.0.0.1:80 )

#Two kind of step solution for it:
#1. Client(in this case next.js app) direct reach service
#In auth-depl.yaml we create a auth-srv service - So ANYTHING in our pod/inside our cluster
#can access this service, therefore the pod that it governs access to.
#So we can call our auth-service from next.js application, and as a domain nam we should pass service name auth-service.

#NOT THE BEST APPROACH - implies that our react will know exact service name for every different thing
#And not only svc names - also which route corresponding to which service

#OPTION NO.2
#Anytime we need to fetch data from a service inside of our kubernetes cluster,
#our next.js app needs to reach out ingress nginx which is already running inside the cluster

#We need to figure out how to make a request directly to ingress nginx when we are inside the cluster
#Next challenge is to get information stored in cookies - as we are running on server side we don't have an acces to the browser
#So we need to check the original,incoming request, extract cookies, and include it to call to ingress nginx

###Cross Namespace Service Communication###
#We can access another pod inside cluster by passing the cluster ip service name, i.e. http://auth-srv
#This is valid only when we are working in the same Namespace

#Namespace - is an element of kubernetess. Used for organizing different objects
#Most of our objects are in default Namespace
#We can't use auth-srv as it's not in default Namespace

#We need to introduce crossnamespace Communication
#Following is a pattern for domain namespace:
$http://NAMEOFSERVICCE.NAMESPACE.svc.cluster.local

#To check namespaces:
$kubectl get namespace

#To check all services in ingress-nginx namespace
$kubectl get services -n ingress-nginx

#So in our case:
$http://ingress-nginx.ingress-nginx.svc.cluster.local

#To avoid nasty naming - we need to introduce external name service

#238. When is getInitialProps called?
#So to introduce all above:
#Request from browser -> Use baseurl in axios of just empty stringify
#If rqeuest from next js during ssr - reach directly to auth svc // ingress-nginx
#Need to figure out where request come from - browser or SS?

#Two cases: Request from component // Request from  getIntiialProps
#Component - Always issued from the browser so use a domain of '',
#Might be executed from the client or the server! Needs to figure out what our env is so we can use the correct domain
#getInitialProps MAY BE executed from browser as well (in particular circumstances)
 
### REQUEST SOURCES ###
#1. Executed on the server
#   - hard refresh of pages
#   - clicking link from different domain
#   - typing url into address braces

#2. Executed from one page to another while in the app
#   - getInitialProps executed on the client

#To verify where it come from- check if window object exist
#Next thing is to check our ingress-srv.yaml file
#ATM routing rules are specified under host ticketing.dev
#Nginx needs to know about host which we'd like to reach
#If we are navigate inside our app we are including domain name in the request (ticketing.dev)
#If it's comming from browser - request can be easily inspect

#If we are doing it from server - there is no way to establish what domain it came from




