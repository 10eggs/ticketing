$npm init -y // all default on YES
$npm install typescript ts-node-dev express @types/express

$tsc --init


#This time we are running Kubernetess stuff directly, straight after creation of new service
warning: LF will be replaced by CRLF in ticketing/auth/package-lock.json.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in ticketing/auth/package.json.
The file will have its original line endings in your workingss





#If you did not see your server restart after changing the index.ts file, do the following:
#Open the package.json file in the ‘auth’ directory
#Find the ‘start’ script
#Update the start script to the following:
$ts-node-dev --poll src/index.ts

#To run skaffold
$skaffold dev

#To prevent problem with cert in chrome
$thisisunsafe

#Remove dir from git
$git rm -r --cached myFolder

#To interact between TS and Mongoose we need to write some custom code as mongoose doesn't support TS natively

#Mongoose User Model - Represents the entire colletion of users
#Mongoose User Document - Represents one single user
#Initially there is no check against constructor properties, which means you can do typo in property name for example and TS will not complain

#Creating User Model
#1. Create scheme - tell mongoose specifically about all the different properties that model will going to have
#2. Create a model in MongoDB
#3. ISSUE no1: When I'll try to create User object with passing any arguments, there is no check provided by TS, so I can do a mistake by passing wrong arguments
#4. Solution - create an interface which describe constructor properties. Next, use new build() function to use interface
#5. build() function need to be connected to User model. We can achieve it by add 'static' property to the model
#6. Initially, we'll end up with error - TS doesn't understand what does it mean to assign a property to a static object
#7. Hence we need to boost our Model to be aware of this function
#8. Solution - introduce another interface to describe what properties our User model should have
#9. In UserModel interface we are introducing GENERICS
#10. After that our mongoose.model will have two generic arguments - any and UserModel
#11. ISSUE no2: Let's say I'd like to print my UserDocument in console - it shows me all properties, even these ones which are added by mongoose automatically.
#12. Solution: Introduce interface for User Document
#13. 

#Hashing Password
#1. Signup process
#2. Create salt
#3. Buffer - raw array of byte inside of it

#Middleware in Mongoose
#1. using .pre()
#2. using function rather than arrow function. Whenever we are calling middleware function we've got an access
# to Entity which we are going to persist to database by calling 'this' keyword - if we would use arrow function instead then 'this' refeering to context of entire file


#AUTHENTICATION STRATEGIES!
# To handle cookies we'll be using cookie-session package:
# npm install cookie-session @types/cookie-session
# to create JWT we need jsonwebtoken

#Useful links:
#https://www.base64decode.org/
#jwt.io

#Securely Storing Secrets with Kubernetes
#In order to do that - use Secret object in kubernetes
#Imperative approach (by using command):
$kubectl create secrete generic jwt-secret --from-literal=<KEY>=<VALUE>
#kubectl create secret genertic jwt-secret --from-literal=JWT_KEY=9283hdin92unc9e0j2neAASUDH


#To get Secrets
$kubectl get secrets

#Mongo db returns '_id', which is usually called 'id'
 #This lines won't work in TS as TS can't detect if this env variable was created or not
  const userJwt = jwt.sign({
    id: user.id,
    email: user.email
  },process.env.JWT_KEY);

  #To mitigate this problem we are going to implement handler which detect during the boot process if env variable is there or not
  #EXCLAMATION MARK in typescript indicate that we have handled suggested error, and typescript shouldn't worry about it


#We can override the way how the javascript object is represented by JSON.stringify. To do so, we need to implement toJSON() method for our object, i.e.:
$const person = {name='Tomek',toJSON(){return 1;}}
#It always return 1

#SHORTCUT
#Ctrl+Shift+` to create new terminal.

#SHORTCUT
#ctrl+shift+p - open PANE
#ctrl+e - search files by name

#Middleware always run in order

#CurrentUser - to prevent access to cookies from the browser
#After creation of CurrentUser handler we want to introduce another middleware to set access to routes can be used by current user.
#


#INTRODUCING TESTS TO OUR PROJECT
#supertest doesn't manage cookie for us by default
#Why we are using SSR rather than CSR?

#1. Just to show how to handle it in microservices world,
#2. Better for mobile devices
#3. Better for SEO 


#Suggestion Regarding a Default Export Warning
#Information:
#Anonymous arrow functions cause Fast Refresh to not preserve local component state.

#Please add a name to your function, for example:
#Before
#export default () => <div />;
#After
#const Named = () => <div />;
#export default Named;


#Starting with Next.JS
#In each file inside pages directory we'll be exporting React components
#Next.js working differently than React router
#Whenever next.js started it is reading all the files from pages folder
#Next can distinct files by names and treat this filenames as a routes
